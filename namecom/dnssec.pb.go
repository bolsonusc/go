// Code generated by protoc-gen-go. DO NOT EDIT.
// source: namecom/dnssec.proto

package namecom

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "google.golang.org/genproto/googleapis/api/annotations"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type DNSSEC struct {
	// Domain_name is the domain name.
	DomainName string `protobuf:"bytes,1,opt,name=domain_name" json:"domain_name,omitempty"`
	// Key_tag contains the key tag value of the DNSKEY RR that validates this signature. The algorithm to generate it is here: https://tools.ietf.org/html/rfc4034#appendix-B
	KeyTag int32 `protobuf:"varint,2,opt,name=key_tag" json:"key_tag,omitempty"`
	// Algorithm is an integer identifying the algorithm used for signing. Valid values can be found here: https://www.iana.org/assignments/dns-sec-alg-numbers/dns-sec-alg-numbers.xhtml
	Algorithm int32 `protobuf:"varint,3,opt,name=algorithm" json:"algorithm,omitempty"`
	// Digest_type is an integer identifying the algorithm used to create the digest. Valid values can be found here: https://www.iana.org/assignments/ds-rr-types/ds-rr-types.xhtml
	DigestType int32 `protobuf:"varint,4,opt,name=digest_type" json:"digest_type,omitempty"`
	// Digest is a digest of the DNSKEY RR that is registered with the registry.
	Digest string `protobuf:"bytes,5,opt,name=digest" json:"digest,omitempty"`
}

func (m *DNSSEC) Reset()                    { *m = DNSSEC{} }
func (m *DNSSEC) String() string            { return proto.CompactTextString(m) }
func (*DNSSEC) ProtoMessage()               {}
func (*DNSSEC) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *DNSSEC) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

func (m *DNSSEC) GetKeyTag() int32 {
	if m != nil {
		return m.KeyTag
	}
	return 0
}

func (m *DNSSEC) GetAlgorithm() int32 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

func (m *DNSSEC) GetDigestType() int32 {
	if m != nil {
		return m.DigestType
	}
	return 0
}

func (m *DNSSEC) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

type ListDNSSECsRequest struct {
	// Domain_name is the domain name to list keys for.
	DomainName string `protobuf:"bytes,1,opt,name=domain_name" json:"domain_name,omitempty"`
}

func (m *ListDNSSECsRequest) Reset()                    { *m = ListDNSSECsRequest{} }
func (m *ListDNSSECsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListDNSSECsRequest) ProtoMessage()               {}
func (*ListDNSSECsRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *ListDNSSECsRequest) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

type ListDNSSECsResponse struct {
	// Dnssec is the list of registered DNSSEC keys.
	Dnssec []*DNSSEC `protobuf:"bytes,1,rep,name=dnssec" json:"dnssec,omitempty"`
	// Next_page is the identifier for the next page of results. It is only populated if there is another page of results after the current page.
	NextPage int32 `protobuf:"varint,2,opt,name=next_page" json:"next_page,omitempty"`
	// Last_page is the identifier for the final page of results. It is only populated if there is another page of results after the current page.
	LastPage int32 `protobuf:"varint,3,opt,name=last_page" json:"last_page,omitempty"`
}

func (m *ListDNSSECsResponse) Reset()                    { *m = ListDNSSECsResponse{} }
func (m *ListDNSSECsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListDNSSECsResponse) ProtoMessage()               {}
func (*ListDNSSECsResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *ListDNSSECsResponse) GetDnssec() []*DNSSEC {
	if m != nil {
		return m.Dnssec
	}
	return nil
}

func (m *ListDNSSECsResponse) GetNextPage() int32 {
	if m != nil {
		return m.NextPage
	}
	return 0
}

func (m *ListDNSSECsResponse) GetLastPage() int32 {
	if m != nil {
		return m.LastPage
	}
	return 0
}

type GetDNSSECRequest struct {
	// Domain_name is the domain name.
	DomainName string `protobuf:"bytes,1,opt,name=domain_name" json:"domain_name,omitempty"`
	// Digest is the digest for the DNSKEY RR to retrieve.
	Digest string `protobuf:"bytes,2,opt,name=digest" json:"digest,omitempty"`
}

func (m *GetDNSSECRequest) Reset()                    { *m = GetDNSSECRequest{} }
func (m *GetDNSSECRequest) String() string            { return proto.CompactTextString(m) }
func (*GetDNSSECRequest) ProtoMessage()               {}
func (*GetDNSSECRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *GetDNSSECRequest) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

func (m *GetDNSSECRequest) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

type DeleteDNSSECRequest struct {
	// Domain_name is the domain name the key is registered for.
	DomainName string `protobuf:"bytes,1,opt,name=domain_name" json:"domain_name,omitempty"`
	// Digest is the digest for the DNSKEY RR to remove from the registry.
	Digest string `protobuf:"bytes,2,opt,name=digest" json:"digest,omitempty"`
}

func (m *DeleteDNSSECRequest) Reset()                    { *m = DeleteDNSSECRequest{} }
func (m *DeleteDNSSECRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteDNSSECRequest) ProtoMessage()               {}
func (*DeleteDNSSECRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *DeleteDNSSECRequest) GetDomainName() string {
	if m != nil {
		return m.DomainName
	}
	return ""
}

func (m *DeleteDNSSECRequest) GetDigest() string {
	if m != nil {
		return m.Digest
	}
	return ""
}

func init() {
	proto.RegisterType((*DNSSEC)(nil), "namecom.DNSSEC")
	proto.RegisterType((*ListDNSSECsRequest)(nil), "namecom.ListDNSSECsRequest")
	proto.RegisterType((*ListDNSSECsResponse)(nil), "namecom.ListDNSSECsResponse")
	proto.RegisterType((*GetDNSSECRequest)(nil), "namecom.GetDNSSECRequest")
	proto.RegisterType((*DeleteDNSSECRequest)(nil), "namecom.DeleteDNSSECRequest")
}

func init() { proto.RegisterFile("namecom/dnssec.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 643 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x54, 0x4f, 0x6b, 0x13, 0x4d,
	0x18, 0x67, 0x92, 0x37, 0x29, 0x99, 0x14, 0xfa, 0x32, 0x95, 0xb2, 0xa6, 0x3d, 0x84, 0x29, 0xc5,
	0xd8, 0x96, 0x6c, 0xb3, 0xd9, 0x4d, 0x37, 0x39, 0x99, 0x6c, 0x36, 0xbd, 0x68, 0x0f, 0x5b, 0x4f,
	0xda, 0x12, 0xc6, 0x66, 0x58, 0xa3, 0xd9, 0x9d, 0x35, 0x33, 0x6a, 0x4b, 0xe9, 0xc5, 0x63, 0x4e,
	0x82, 0x97, 0x0a, 0xe2, 0x45, 0xf0, 0x1b, 0xe4, 0x03, 0x78, 0x13, 0xaf, 0x7e, 0x05, 0x3f, 0x88,
	0x74, 0x67, 0xb3, 0xd9, 0xa6, 0x81, 0x8a, 0x22, 0x78, 0x9c, 0xe7, 0xf7, 0xf0, 0x3c, 0xf3, 0xfb,
	0xc3, 0x03, 0x6f, 0xf9, 0xc4, 0xa3, 0xc7, 0xcc, 0x53, 0x7b, 0x3e, 0xe7, 0xf4, 0xb8, 0x1c, 0x0c,
	0x99, 0x60, 0x68, 0x21, 0xaa, 0x16, 0x56, 0x27, 0x30, 0xf5, 0x02, 0x71, 0x3a, 0xa4, 0x3c, 0x60,
	0x3e, 0xa7, 0xb2, 0xab, 0xb0, 0xe6, 0x32, 0xe6, 0x0e, 0xa8, 0x4a, 0x82, 0xbe, 0x4a, 0x7c, 0x9f,
	0x09, 0x22, 0xfa, 0xcc, 0xe7, 0x12, 0xc5, 0x6f, 0x53, 0x30, 0xdb, 0xde, 0x3f, 0x38, 0xb0, 0x2d,
	0x64, 0xc0, 0x7c, 0x8f, 0x79, 0xa4, 0xef, 0x77, 0x2f, 0xc7, 0x29, 0xa0, 0x08, 0x4a, 0xb9, 0xd6,
	0xf2, 0x68, 0xac, 0xe4, 0xe9, 0x09, 0xf1, 0x82, 0x01, 0x2d, 0xb3, 0xa1, 0x7b, 0x31, 0x56, 0x80,
	0x93, 0xec, 0x43, 0xeb, 0x70, 0xe1, 0x39, 0x3d, 0xed, 0x0a, 0xe2, 0x2a, 0xa9, 0x22, 0x28, 0x65,
	0x5a, 0xb9, 0xd1, 0x58, 0xc9, 0x54, 0x77, 0xea, 0x3b, 0x75, 0x67, 0x82, 0xa0, 0x75, 0x98, 0x23,
	0x03, 0x97, 0x0d, 0xfb, 0xe2, 0xa9, 0xa7, 0xa4, 0xc3, 0xb6, 0xcc, 0x68, 0xac, 0x00, 0xd3, 0x99,
	0xd6, 0xd1, 0x1d, 0x98, 0xef, 0xf5, 0x5d, 0xca, 0x45, 0x57, 0x9c, 0x06, 0x54, 0xf9, 0x6f, 0xda,
	0xa6, 0x39, 0x49, 0x04, 0x1d, 0xc2, 0xac, 0x7c, 0x2a, 0x99, 0xf0, 0x93, 0xed, 0xd1, 0x58, 0xb9,
	0x67, 0x6b, 0xed, 0xaa, 0x55, 0xaf, 0xd4, 0x3a, 0xb5, 0xb6, 0x6d, 0x37, 0xad, 0xdd, 0xaa, 0x56,
	0xd7, 0x6d, 0x53, 0xab, 0x99, 0x9d, 0x96, 0x61, 0x9a, 0xc6, 0x8e, 0xae, 0x37, 0xcd, 0x6a, 0xb5,
	0x63, 0x19, 0xba, 0x51, 0x37, 0x4c, 0xb3, 0xa3, 0x37, 0xeb, 0x15, 0x53, 0xb7, 0x3a, 0x96, 0x5e,
	0x69, 0x1a, 0xbb, 0xb5, 0x9a, 0x13, 0xcd, 0xc4, 0x7b, 0x10, 0xdd, 0xef, 0x73, 0x21, 0x55, 0xe1,
	0x0e, 0x7d, 0xf1, 0x92, 0x72, 0x81, 0x2a, 0xf3, 0xd4, 0x59, 0x9a, 0x51, 0xe7, 0x8a, 0x32, 0xf8,
	0x43, 0x0a, 0x2e, 0x5f, 0x99, 0x24, 0x7d, 0x41, 0x5f, 0x01, 0xcc, 0x4a, 0x23, 0x15, 0x50, 0x4c,
	0x97, 0xf2, 0xda, 0x52, 0x39, 0x32, 0xb0, 0x2c, 0x5b, 0x5b, 0x1f, 0xc1, 0x68, 0xac, 0xbc, 0x07,
	0x8f, 0xcf, 0x70, 0x72, 0x5e, 0x03, 0x27, 0x56, 0xe1, 0x6d, 0x1c, 0x89, 0x8b, 0x1b, 0xa1, 0xd8,
	0xdb, 0x38, 0x56, 0x12, 0x37, 0xcc, 0x6d, 0x9c, 0x10, 0x0c, 0x37, 0xb4, 0xc9, 0x1b, 0x37, 0xf0,
	0x9f, 0x0a, 0x85, 0xcf, 0x8f, 0x9c, 0xe8, 0xff, 0x68, 0x0d, 0xe6, 0x7c, 0x7a, 0x22, 0xba, 0x01,
	0x71, 0xa9, 0xb4, 0xdf, 0x99, 0x16, 0x2e, 0xd1, 0x01, 0xe1, 0x11, 0x9a, 0x96, 0x68, 0x5c, 0xc0,
	0x9f, 0x00, 0xfc, 0x7f, 0x8f, 0x46, 0xea, 0xfc, 0xbe, 0xcc, 0x89, 0x34, 0xa4, 0xfe, 0x42, 0x1a,
	0x3e, 0x03, 0xb8, 0xdc, 0xa6, 0x03, 0x2a, 0xe8, 0xbf, 0xfd, 0x51, 0xed, 0x4b, 0x1a, 0x2e, 0x44,
	0x49, 0x43, 0x43, 0x98, 0x4f, 0x04, 0x0f, 0xad, 0xc6, 0xf9, 0xba, 0x1e, 0xec, 0xc2, 0xda, 0x7c,
	0x50, 0x66, 0x15, 0x97, 0xde, 0x7c, 0xff, 0xf1, 0x2e, 0x85, 0x51, 0x51, 0x7d, 0xa5, 0xab, 0x92,
	0x0c, 0x57, 0xcf, 0x12, 0xac, 0xce, 0xa3, 0x9b, 0x84, 0x9e, 0xc1, 0x5c, 0xec, 0x26, 0xba, 0x1d,
	0x0f, 0x9d, 0x75, 0xb8, 0x30, 0x1b, 0x76, 0x5c, 0x09, 0x57, 0x6c, 0xa1, 0xbb, 0x37, 0xad, 0x50,
	0xcf, 0x24, 0xd5, 0x73, 0x74, 0x04, 0x17, 0xad, 0x21, 0x25, 0x13, 0x4f, 0xd0, 0xec, 0xcc, 0xeb,
	0x4b, 0xb6, 0xc2, 0x25, 0x1b, 0xf8, 0x46, 0x1e, 0x0d, 0xb0, 0x89, 0x5e, 0xc3, 0xc5, 0xa4, 0xe5,
	0x68, 0x2a, 0xd1, 0x9c, 0x24, 0x14, 0x56, 0x62, 0xd4, 0xbe, 0x3c, 0xbf, 0xb1, 0x74, 0x11, 0xaf,
	0xcd, 0x5f, 0xe7, 0xd5, 0xda, 0x78, 0x34, 0xb9, 0xe9, 0x17, 0x00, 0x7c, 0x4b, 0xad, 0xec, 0x13,
	0x8f, 0xb6, 0x99, 0xb0, 0x98, 0x77, 0xe8, 0xd8, 0x07, 0x0f, 0x0f, 0x1f, 0xb0, 0x1e, 0x1d, 0xf0,
	0x27, 0xd9, 0xf0, 0x76, 0x57, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0x96, 0x8f, 0xe4, 0x81, 0x17,
	0x06, 0x00, 0x00,
}
